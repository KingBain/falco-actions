name: 'Falco Action Start'
description: 'Run Falco in a GitHub action'
author: 'The Falco Authors'
inputs:
  mode: 
    description: 'Start action with a mode. Can be live or analyze'
    type: choice
    options:
      - live
      - analyze
    required: false
    default: 'live'
  falco-version: 
    description: 'Falco version to use'
    type: string
    required: false
    default: 'latest'
  config-file:
    description: 'Start action with a config file. Only used in analyze mode'
    type: string
    required: false
    default: 'src/syscall_ignore.config'
  custom-rule-file:
    description: 'Custom rule file'
    type: string
    default: ''
    required: false
  cicd-rules:
    description: 'Load the default CICD rulesn from the Falco community'
    type: boolean
    required: false
    default: true
  verbose:
    description: 'Enable verbose logs'
    type: boolean
    required: false
    default: false
runs:
  using: 'composite'
  steps:

  - name: Check for BPF ring buffer support
    shell: bash
    run: |
      echo "Probing host BPF ring buffer support"
      # ensure bpftool is installed (as before)
      if ! command -v bpftool &> /dev/null; then
        sudo apt-get update -qq
        sudo apt-get install -y -qq linux-tools-$(uname -r)
      fi

      # probe the kernel, then look for the ringbuf map type
      if ! sudo bpftool feature probe kernel \
        | grep -q "map_type ringbuf is available"; then
        echo "BPF ring buffer NOT supported on this runner"
        exit 1
      fi

      echo "BPF ring buffer supported"

  - name: Check for BTF tracepoint support
    if: ${{ inputs.mode == 'analyze' }}
    shell: bash
    run: |
      echo "Probing host eBPF tracing support (BTF)"
      if ! sudo bpftool feature probe kernel \
        | grep -q "program_type tracing is available"; then
        echo "eBPF tracing programs NOT supported on this runner"
        exit 1
      fi

      echo "BTF tracing support available"

  - name: Start Falco Rules Engine
    if: ${{ inputs.mode == 'live' }}
    env:
      VERBOSE: ${{ inputs.verbose }}
      FALCO_VERSION: ${{ inputs.falco-version }}
      CUSTOM_RULE_FILE: ${{ inputs.custom-rule-file }}
      DEFAULT_CI_CD_RULES: ${{ inputs.cicd-rules }}
    shell: bash
    run: |
      if [[ "$VERBOSE" == "true" ]]; then
        set -x
      fi

      if [[ -f "$CUSTOM_RULE_FILE" ]]; then
        if [ "$VERBOSE" = "true" ]; then
          echo "Loading custom rules from $CUSTOM_RULE_FILE"
        fi
        MOUNT_CUSTOM_RULE="-v $CUSTOM_RULE_FILE:/etc/falco/rules.d/custom_rules.yaml"
      fi

      if [[ "$DEFAULT_CI_CD_RULES" == "true" ]]; then
        if [ "$VERBOSE" = "true" ]; then
          echo "Loading default CICD rules"
        fi
        MOUNT_CICD_DEFAULT_RULES="-v ${{github.action_path}}/rules/falco_cicd_rules.yaml:/etc/falco/rules.d/cicd_rules.yaml"
      fi

      docker run --rm -d \
        --name falco \
        --privileged \
        -v /tmp:/tmp \
        -v /var/run/docker.sock:/host/var/run/docker.sock \
        -v /proc:/host/proc:ro \
        -v /etc:/host/etc:ro \
        $MOUNT_CUSTOM_RULE \
        $MOUNT_CICD_DEFAULT_RULES \
        falcosecurity/falco-no-driver:$FALCO_VERSION falco -o "json_output=true" -o "file_output.enabled=true" -o "file_output.keep_alive=false" -o "file_output.filename=/tmp/falco_events.json" -o "engine.kind=modern_ebpf"

      # Wait for the Falco container to be fully started
      for i in {1..30}; do
        if docker ps --filter "name=falco" --filter "status=running" | grep -q falco; then
          break
        fi
        sleep 1
      done

      if ! docker ps --filter "name=falco" --filter "status=running" | grep -q falco; then
        echo "Falco container failed to start"
        exit 1
      fi

      docker logs falco

  - name: Start Sysdig System Capture
    if: ${{ inputs.mode == 'analyze' }}
    env:
      VERBOSE: ${{ inputs.verbose }}
      CONFIG_FILE: ${{ inputs.config-file }}
    shell: bash
    run: |
      if [[ "$VERBOSE" == "true" ]]; then
        set -x
      fi

      IGNORE_FILTER_FOLDER=${{github.action_path}}/src
      
      if [ "$CONFIG_FILE" != "src/syscall_ignore.config" ]; then
        echo "Using custom config file $CONFIG_FILE"
      else
        echo "Using default config"
        CONFIG_FILE="${{github.action_path}}/$CONFIG_FILE"
      fi

      if [ ! -e "$CONFIG_FILE" ]; then
        echo "Config file $CONFIG_FILE does not exist."
        exit 1
      fi

      if [[ "$VERBOSE" == "true" ]]; then
        echo "Config File:"
        cat $CONFIG_FILE
      fi

      echo "Creating ignore filters"
      IGNORE_SYSCALLS_FILTER="and not evt.type in ( $(jq -r -f $IGNORE_FILTER_FOLDER/ignore_syscalls.jq $CONFIG_FILE) ) "

      if [[ "$VERBOSE" == "true" ]]; then
        echo "Ignored Syscalls:"
        echo $IGNORE_SYSCALLS_FILTER
      fi

      echo "Starting Sysdig capture with modern BPF"
      docker run --rm -d \
        --name sysdig \
        --privileged \
        --entrypoint /usr/bin/sysdig \
        -v /var/run/docker.sock:/host/var/run/docker.sock \
        -v /dev:/host/dev \
        -v /proc:/host/proc:ro \
        -v /sys/fs/bpf:/sys/fs/bpf:ro \
        -v /sys/kernel/btf:/sys/kernel/btf:ro \
        -v /tmp:/tmp \
        --net=host \
        sysdig/sysdig:latest \
        --modern-bpf \
        -w /tmp/capture.scap \
        --snaplen=256 \
        "not evt.type in (switch) $IGNORE_SYSCALLS_FILTER"

      echo "Sysdig started in modern-bpf mode"

      # Ensure Sysdig container is running
      sleep 10 # todo(loresuso): replace with a more robust check

      # Wait for the Sysdig container to be fully started
      for i in {1..30}; do
        if docker ps --filter "name=sysdig" --filter "status=running" | grep -q sysdig; then
          break
        fi
        sleep 1
      done

      if ! docker ps --filter "name=sysdig" --filter "status=running" | grep -q sysdig; then
        echo "Sysdig container failed to start"
        exit 1
      fi

      if [[ "$VERBOSE" == "true" ]]; then
        docker ps -a
        docker logs sysdig
      fi
